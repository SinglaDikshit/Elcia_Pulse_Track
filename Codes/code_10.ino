#include <Adafruit_GFX.h>  // library for oled display 
#include <Adafruit_ST7735.h>  // library for oled display
#include <Wire.h>  //I2C communicatio lib
#include <SPI.h>   // SPI communication library

#include <MAX30105.h>   //library for MAX30102
#include "spo2_algorithm.h"  //caculation of SpO2
#include "heartRate.h"    //calculation of Heart rate
#include <Adafruit_MPU6050.h> // MPU library
#include <Adafruit_Sensor.h>   //unified library

// ST7735 setup
#define TFT_CS     5
#define TFT_RST    17
#define TFT_DC     16

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

// MAX30102
MAX30105 particleSensor;

// MPU6050
Adafruit_MPU6050 mpu;

// Sensor data
const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred

unsigned long lastDisplayUpdate = 0;
const unsigned long displayInterval = 5000; // in milliseconds

float beatsPerMinute;
int beatAvg;
// bit map 'heart logo', 50x49px
const unsigned char epd_bitmap_heart [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xf0, 0x1f, 0xfe, 0x03, 0xff, 0xc0, 0xff, 
  0xc0, 0x07, 0xf8, 0x00, 0xff, 0xc0, 0xff, 0x83, 0xf9, 0xe7, 0xf0, 0x7f, 0xc0, 0xff, 0x8f, 0xfc, 
  0xcf, 0xfc, 0x7f, 0xc0, 0xff, 0x1f, 0xfe, 0xdf, 0xfe, 0x3f, 0xc0, 0xff, 0x3f, 0xff, 0x3f, 0xfe, 
  0x3f, 0xc0, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0x1f, 0xc0, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0x1f, 0xc0, 
  0xfe, 0x3f, 0xff, 0xff, 0xff, 0x1f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0xfe, 0x00, 
  0x00, 0x00, 0x00, 0x1f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0xfe, 0x00, 0x00, 0x00, 
  0x00, 0x1f, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 
  0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0xff, 0xc0, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xc0, 0xff, 0xe0, 0x00, 0x00, 0x01, 
  0xff, 0xc0, 0xff, 0xf0, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xf8, 0x00, 0x00, 0x07, 0xff, 0xc0, 
  0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0xff, 0xff, 
  0x00, 0x00, 0x3f, 0xff, 0xc0, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 
  0xff, 0xff, 0xc0, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 
  0xc0, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xc0, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 368)
const int epd_bitmap_allArray_LEN = 1;
const unsigned char* epd_bitmap_allArray[1] = {
  epd_bitmap_heart
};

// bit map 'o2_random', 50x50px
const unsigned char epd_bitmap_o2 [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xc0, 0xff, 
  0xff, 0xdc, 0xff, 0xe0, 0xff, 0xc0, 0xff, 0xff, 0xbe, 0xff, 0xdf, 0x7f, 0xc0, 0xff, 0xff, 0xbf, 
  0x03, 0xbf, 0xbf, 0xc0, 0xf8, 0x3f, 0xbf, 0xfc, 0x7f, 0xdf, 0xc0, 0xf7, 0x9f, 0xbf, 0xff, 0x7f, 
  0xdf, 0xc0, 0xef, 0xde, 0x7f, 0xff, 0xff, 0xdf, 0xc0, 0xef, 0xdd, 0xff, 0xff, 0xff, 0xdf, 0xc0, 
  0xef, 0xdd, 0xff, 0xff, 0xff, 0xdf, 0xc0, 0xf7, 0xdb, 0xff, 0xff, 0xff, 0xbf, 0xc0, 0xf3, 0xb7, 
  0xff, 0xe1, 0xfe, 0x7f, 0xc0, 0xfc, 0x77, 0xff, 0xfe, 0xf9, 0xff, 0xc0, 0xff, 0xef, 0xff, 0xfe, 
  0xfd, 0x87, 0xc0, 0xff, 0xef, 0xe0, 0xe0, 0xfd, 0x7b, 0xc0, 0xff, 0xef, 0xde, 0xef, 0xfc, 0xfb, 
  0xc0, 0xff, 0xef, 0xde, 0xcf, 0xfc, 0xfb, 0xc0, 0xff, 0xef, 0xde, 0xcf, 0xfc, 0xfb, 0xc0, 0xff, 
  0xef, 0xde, 0xcf, 0xfc, 0x7b, 0xc0, 0xff, 0xef, 0xde, 0xc0, 0xfd, 0x87, 0xc0, 0xff, 0xef, 0xde, 
  0xe0, 0xfd, 0xff, 0xc0, 0xff, 0xef, 0xde, 0xff, 0xfd, 0xff, 0xc0, 0xff, 0xef, 0xde, 0xff, 0xfd, 
  0xff, 0xc0, 0xff, 0xf7, 0xde, 0xff, 0xfc, 0xff, 0xc0, 0xff, 0xf7, 0xe0, 0xff, 0xff, 0x7f, 0xc0, 
  0xff, 0xfb, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xf3, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xcf, 
  0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xbf, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xbf, 0xff, 0xff, 
  0x7f, 0x7f, 0xc0, 0xff, 0x7f, 0xff, 0xfc, 0x3e, 0xff, 0xc0, 0xff, 0x7f, 0xfc, 0x03, 0xc1, 0xff, 
  0xc0, 0xff, 0x7f, 0xfd, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x7f, 0xfd, 0xff, 0xff, 0xff, 0xc0, 0xff, 
  0x7f, 0xfd, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x7f, 0xfd, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x7f, 0xfb, 
  0xff, 0xff, 0xff, 0xc0, 0xff, 0xbf, 0xfb, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xdf, 0xf7, 0xff, 0xff, 
  0xff, 0xc0, 0xff, 0xe7, 0xcf, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xc0, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 368)
const int epd_bitmap_allArray_LEN_2 = 1;
const unsigned char* epd_bitmap_allArray_2[1] = {
  epd_bitmap_o2
};


void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);

  // Display
  tft.initR(INITR_BLACKTAB); // For ST7735
  tft.setRotation(0);
  tft.fillScreen(ST77XX_WHITE);
  tft.setTextColor(ST77XX_BLACK);
  tft.setTextSize(1);
  tft.setCursor(0, 0);
  
  tft.println("Initializing...");

  // MAX30102
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    tft.println("MAX30102 not found!");
    while (1);
  }
  particleSensor.setup(); //Configure sensor with default settings
  particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
  particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED
 
  // MPU6050
  if (!mpu.begin()) {
    tft.println("MPU6050 not found!");
    while (1);
  }

  mpu.setAccelerometerRange(MPU6050_RANGE_4_G);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  delay(1000);
  tft.fillScreen(ST77XX_BLACK);
}

void loop() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

   long irValue = particleSensor.getIR();

  if (checkForBeat(irValue) == true)
  {
    //We sensed a beat!
    long delta = millis() - lastBeat;
    lastBeat = millis();

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20)
    {
      rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array
      rateSpot %= RATE_SIZE; //Wrap variable

      //Take average of readings
      beatAvg = 0;
      for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
      beatAvg /= RATE_SIZE;
    }
  }



  if (millis() - lastDisplayUpdate > displayInterval) {
    lastDisplayUpdate = millis();

if (irValue < 50000){
    tft.fillScreen(ST77XX_WHITE);   //setting white background 
    tft.setCursor(0, 0);
    tft.print(" No finger?");}

    else{
  // Display output
  mpu.getEvent(&a, &g, &temp);

tft.fillScreen(ST77XX_WHITE);
tft.setCursor(0, 0);
  
tft.drawBitmap(0, 0, epd_bitmap_heart, 50, 49, ST77XX_RED);
tft.setCursor(66, 15);
tft.setTextSize(2); 
tft.print(beatAvg);


  
//  tft.print("HR: ");
//  tft.print(heartRate);
//  tft.print(" bpm ");
//  tft.println(validHeartRate ? "OK" : "X");
//
tft.setCursor(0, 50);
tft.drawBitmap(0, 50, epd_bitmap_o2, 50,50, ST77XX_RED);
tft.setCursor(66, 65);
tft.setTextSize(2); 
tft.print("spo2");
tft.print("% ");
//  tft.println(validSPO2 ? "OK" : "X"); 
//
tft.setTextSize(1);
tft.setCursor(0, 101);
tft.drawRect(0, 101, 128, 160,ST77XX_RED);
tft.setTextSize(1);
tft.setCursor(15, 102);
tft.print("Acc:  ");
tft.print("X: ");
tft.println(a.acceleration.x, 2);
tft.setCursor(15, 110);
tft.print("      ");
tft.print("Y: ");
tft.println(a.acceleration.y, 2);
tft.setCursor(15, 118);
tft.print("      ");
tft.print("Z: ");
tft.println(a.acceleration.z, 2);
tft.setCursor(15, 126);
tft.print("ROT:  ");
tft.print("X: ");
tft.println(g.gyro.x, 2);
tft.setCursor(15, 134);
tft.print("      ");
tft.print("Y: ");
tft.println(g.gyro.y, 2);
tft.setCursor(15, 142);
tft.print("      ");
tft.print("Z: ");
tft.println(g.gyro.z, 2);
//
//tft.setCursor(15, 150);
//  tft.print("Temp: ");
//  tft.print(temp.temperature, 1);
//  tft.println(" C");
  }
  }
Serial.print("HR:");
Serial.print(beatAvg);
Serial.print(",SpO2:");
Serial.print("spo2");
//Serial.print(",Temp:");
//Serial.print(temp.temperature);  // had to non-availability of required sensor
Serial.print(",Ax:");
Serial.print(a.acceleration.x);
Serial.print(",Ay:");
Serial.print(a.acceleration.y);
Serial.print(",Az:");
Serial.println(a.acceleration.z);
Serial.print(",Ax:");
Serial.print(a.acceleration.x);
Serial.print(",Ay:");
Serial.print(a.acceleration.y);
Serial.print(",Az:");
Serial.println(a.acceleration.z);
Serial.print(",Rx:");
Serial.print(g.gyro.x);
Serial.print(",Ry:");
Serial.print(g.gyro.y);
Serial.print(",Rz:");
Serial.println(g.gyro.z);

//
//  delay(1000);
}
